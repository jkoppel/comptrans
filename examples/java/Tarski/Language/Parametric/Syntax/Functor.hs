{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverlappingInstances #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
-- | 
-- Module       : Tarski.Language.Parametric.Syntax.Functor
-- Copyright    : (C) 2012-2013 Tarski Technologies, All Rights Reserved
-- Author       : James Koppel
-- 
-- This file provides functorial syntax -- versions of standard functors for
-- use in parametric syntax.

module Tarski.Language.Parametric.Syntax.Functor
  (
    -- * Functorial syntax
    MaybeF(..)
  , ListF(..)
  , PairF(..)

    -- * Smart constructors
  , riNothingF
  , iJustF
  , riNilF
  , iConsF
  , riPairF

    -- * Converting functorial syntax
  , ExtractF(..)
  , KExtractF(..)
  , InsertF(..)
  ) where

import Control.Applicative ( Applicative, pure )
import Control.Monad ( liftM, liftM2 )

import Data.Comp.Multi ( (:<:), (:+:), (:&:), Cxt(..), K(..), unK, inject, caseH, RemA(..) )
import Data.Comp.Multi.Derive ( derive, makeHFunctor, makeHTraversable, makeHFoldable, makeEqHF, makeShowHF, makeOrdHF )

import Data.Type.Equality ( (:~:)(..) )

import qualified GHC.Generics as G

import Tarski.Language.Parametric.Classification
import Tarski.Language.Parametric.InjF

--------------------------------------------------------------------------------
-- Higher-order versions of standard functors
--------------------------------------------------------------------------------

-- | A higher-order functor version of Maybe, for use with
-- multi-sorted compositional data types
-- 
-- @e@ : a functor mapping labels to terms of the corresponding sort
-- 
-- @l@ : the label. Will have the form @Maybe l'@
data MaybeF e l
            where
  NothingF :: MaybeF e (Maybe l)
  JustF :: e l -> MaybeF e (Maybe l)

-- | A higher-order functor version of [], for use with
-- multi-sorted compositional data types
-- 
-- @e@ : a functor mapping labels to terms of the corresponding sort
-- 
-- @l@ : the label. Will have the form [l]
data ListF e l where
  NilF :: ListF e [l]
  ConsF :: e l -> e [l] -> ListF e [l]

-- | A higher-order functor version of (,), for use with
-- multi-sorted compositional data types
-- 
-- @e@ : a functor mapping labels to terms of the corresponding sort
-- 
-- @l@ : the label . Will have the form (l1,l2)

data PairF e l where
  PairF :: e i -> e j -> PairF e (i, j)

--------------------------------------------------------------------------------
-- Instances of Generic
--------------------------------------------------------------------------------

instance G.Generic (MaybeF e (Maybe l)) where
  type Rep (MaybeF e (Maybe l)) = G.U1 G.:+: (G.Rec0 (e l))
  from NothingF      = G.L1 G.U1
  from (JustF x)     = G.R1 $ G.K1 x
  to (G.L1 G.U1)     = NothingF
  to (G.R1 (G.K1 x)) = JustF x

instance G.Generic (ListF e [l]) where
  type Rep (ListF e [l]) = G.U1 G.:+: (G.Rec0 (e l) G.:*: G.Rec0 (e [l]))
  from NilF                        = G.L1 G.U1
  from (ConsF x xs)                = G.R1 $ G.K1 x G.:*: G.K1 xs
  to (G.L1 G.U1)                   = NilF
  to (G.R1 (G.K1 x G.:*: G.K1 xs)) = ConsF x xs


instance G.Generic (PairF e (i,j)) where
  type Rep (PairF e (i,j)) = G.Rec0 (e i) G.:*: G.Rec0 (e j)
  from (PairF x y)         = G.K1 x G.:*: G.K1 y
  to (G.K1 x G.:*: G.K1 y) = PairF x y

--------------------------------------------------------------------------------
-- Trivial instances of Generic
--------------------------------------------------------------------------------

instance G.Generic (MaybeF e [l]) where
  type Rep (MaybeF e [l]) = G.V1
  from = undefined
  to   = undefined

instance G.Generic (MaybeF e (i,j)) where
  type Rep (MaybeF e (i,j)) = G.V1
  from = undefined
  to   = undefined

instance G.Generic (ListF e (Maybe l)) where
  type Rep (ListF e (Maybe l)) = G.V1
  from = undefined
  to   = undefined

instance G.Generic (ListF e (i,j)) where
  type Rep (ListF e (i,j)) = G.V1
  from = undefined
  to   = undefined

instance G.Generic (PairF e (Maybe l)) where
  type Rep (PairF e (Maybe l)) = G.V1
  from = undefined
  to   = undefined

instance G.Generic (PairF e [l]) where
  type Rep (PairF e [l]) = G.V1
  from = undefined
  to   = undefined

--------------------------------------------------------------------------------

-- ProjF instances are usually generated by TH,
-- but the TH currently does not handle higher-kinded labels

instance ProjF (MaybeF e) l l' where
  projF _ =  Nothing

instance (ProjF e l l') => ProjF (MaybeF e) (Maybe l) (Maybe l') where
  projF NothingF = Just NothingF
  projF (JustF x) = liftM JustF $ projF x


instance ProjF (ListF e) l l' where
  projF _ = Nothing

instance (ProjF e l l', ProjF e [l] [l']) => ProjF (ListF e) [l] [l'] where
  projF NilF = Just NilF
  projF (ConsF x xs) = do x'  <- projF x
                          xs' <- projF xs
                          return $ ConsF x' xs'

instance ProjF (PairF e) l l' where
  projF _ = Nothing

instance (ProjF e l l', ProjF e m m') => ProjF (PairF e) (l, m) (l', m') where
  projF (PairF x y) = liftM2 PairF (projF x) (projF y)

--------------------------------------------------------------------------------

-- DynCase instances are usually generated by TH,
-- but the TH currently does not handle higher-kinded labels

instance DynCase e l => DynCase (MaybeF e) (Maybe l) where
  dyncase NothingF = Nothing
  dyncase (JustF x) = do p <- dyncase x
                         return $ combine Refl p
    where
      combine :: (x :~: Maybe y) -> (y :~: l) -> (x :~: Maybe l)
      combine Refl Refl = Refl

instance DynCase e l => DynCase (ListF e) [l] where
  dyncase NilF = Nothing
  dyncase (ConsF x _) = do p <- dyncase x
                           return $ combine Refl p
    where
      combine :: (x :~: [y]) -> (y :~: l) -> (x :~: [l])
      combine Refl Refl = Refl

instance (DynCase e l, DynCase e l') => DynCase (PairF e) (l, l') where
  dyncase (PairF x y) = do p1 <- dyncase x
                           p2 <- dyncase y
                           return $ combine Refl p1 p2
    where
      combine :: (a :~: (b,c)) -> (b :~: l) -> (c :~: l') -> (a :~: (l, l'))
      combine Refl Refl Refl = Refl

--------------------------------------------------------------------------------

-- Fully smart constructors for NothingF and NilF do not
-- typecheck because of unconstrained label

-- | Smart constructor for NothingF. Restricted; cannot be lifted through a sort injection
riNothingF :: (MaybeF :<: f) => Cxt h f a (Maybe l)
riNothingF = inject NothingF

iJustF :: (MaybeF :<: f, InjF (Cxt h f a) (Maybe l) l') => Cxt h f a l -> Cxt h f a l'
iJustF = injectF . JustF

-- | Smart constructor for NilF. Restricted; cannot be lifted through a sort injection
riNilF :: (ListF :<: f) => Cxt h f a [l]
riNilF = inject NilF

iConsF :: (ListF :<: f, InjF (Cxt h f a) [l] l') => Cxt h f a l -> Cxt h f a [l] -> Cxt h f a l'
iConsF x y = injectF (ConsF x y)

-- | Smart constructor for PairF. Restricted; cannot be lifted through a sort injection
riPairF :: (PairF :<: f) => Cxt h f a i -> Cxt h f a j -> Cxt h f a (i, j)
riPairF x y = inject (PairF x y)

$(derive [makeHFunctor, makeHTraversable, makeHFoldable, makeEqHF, makeShowHF,
                    makeOrdHF]
       [''MaybeF, ''ListF, ''PairF])

--------------------------------------------------------------------------------
-- Dealing with functorial syntax
--------------------------------------------------------------------------------

class ExtractF f e where
  -- | Pulls a functor out of a label.
  -- 
  -- Example:
  -- 
  -- @
  -- 'extractF' :: 'JavaProj' ['SourceFileL'] -> ['JavaProj' 'SourceFileL']
  -- @
  -- 
  -- This function is unsafe, as the type system cannot detect when the label
  -- on a higher-order functorial sum guarantees which class the term lies in.
  -- 
  -- We should be able to make this safe using OrderedOverlappingTypeFamilies.
  -- 
  -- This is an instance of a distributive law, and likely can (and should)
  -- be replaced with such.
  extractF :: e (f l) -> f (e l)

-- | Inductive form of ExtractF.
-- An instance @KExtract f g@ gives rise to an instance @ExtractF f (Term g)@
class KExtractF f g where
  kextractF :: ExtractF f e => g e (f l) -> f (e l)

instance (KExtractF f g, KExtractF f h) => KExtractF f (g :+: h) where
  kextractF = caseH kextractF kextractF

instance (KExtractF f g) => KExtractF f (g :&: a) where
  kextractF = kextractF . remA

instance (Applicative f) => ExtractF f (K a) where
  extractF = pure . K . unK

instance (KExtractF f g, ExtractF f a, Functor f) => ExtractF f (Cxt h g a) where
  extractF (Term x) = kextractF x
  extractF (Hole x) = fmap Hole $ extractF x

-- ISSUE
-- Once we have ordered overlapping type families, we can get type-level
-- inequality, and can thus write this in a safer way
instance KExtractF f g where
  kextractF = error "Undefined use of extractF"

--------------------------------------------------------------------------------

instance KExtractF [] ListF where
  kextractF NilF = []
  kextractF (ConsF x xs) = x : (extractF xs)

instance KExtractF Maybe MaybeF where
  kextractF NothingF = Nothing
  kextractF (JustF x) = Just x

--------------------------------------------------------------------------------

class InsertF f e where
  -- | Inverse of extractF. Pushes a functor into a label.
  -- 
  -- Example:
  -- 
  -- @
  -- 'insertF' :: ['JavaProj' 'SourceFileL'] -> 'JavaProj' ['SourceFileL']
  -- @
  -- 
  -- Note that this cannot be used on a labeled tree, as the insertion operation will
  -- require generating additional labels.
  -- 
  -- This is an instance of a distributive law, and can probably be replaced with such.
  insertF :: f (e l) -> e (f l)

instance (ListF :<: e) => InsertF [] (Cxt h e a) where
  insertF [] = riNilF
  insertF (x : xs) = x `iConsF` (insertF xs)

instance (MaybeF :<: e) => InsertF Maybe (Cxt h e a) where
  insertF Nothing = riNothingF
  insertF (Just x) = iJustF x