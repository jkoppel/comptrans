-- |
-- 
-- GHC has a phase restriction which prevents code generated by Template Haskell
-- being referred to by Template Haskell in the same file. Thus, when using this
-- library, you will need to spread invocations out over several files.
-- 
-- We will refer to the following example in the documentation:
-- 
-- @
-- module Foo where
-- data Arith = Add Atom Atom
-- data Atom = Var String | Const Lit
-- data Lit = Lit Int
-- @
module Tarski.Data.Comp.Trans (
    deriveMultiComp
  , generateNameLists
  , makeSumType

  , T.deriveTrans
  , U.deriveUntrans
  ) where

import Control.Monad ( liftM )

import Data.Comp.Multi ( (:+:) )

import Language.Haskell.TH.Quote ( dataToExpQ )
import Language.Haskell.TH

import qualified Tarski.Data.Comp.Trans.DeriveTrans as T
import qualified Tarski.Data.Comp.Trans.DeriveUntrans as U
import Tarski.Data.Comp.Trans.DeriveMulti ( deriveMulti )
import Tarski.Data.Comp.Trans.Collect ( collectTypes )
import Tarski.Data.Comp.Trans.Names ( transName )


-- |
-- Declares a multi-sorted compositional datatype isomorphic to the
-- given ADT.
-- 
-- /e.g./
-- 
-- @
-- import qualified Foo as F
-- deriveMultiComp ''F.Arith
-- @
-- 
-- will create
-- 
-- @
-- data ArithL
-- data AtomL
-- data LitL
-- 
-- data Arith e l where
--   Add :: e AtomL -> e AtomL -> Arith e ArithL
-- 
-- data Atom e l where
--   Var :: String -> Atom e AtomL
--   Const :: e LitL -> Atom e AtomL
-- 
-- data Lit e l where
--   Lit :: Int -> Lit e LitL
-- @
deriveMultiComp :: Name -> Q [Dec]
deriveMultiComp root = do descs <- collectTypes root
                          liftM concat $ mapM deriveMulti descs

-- |
-- 
-- /e.g./
-- 
-- @
-- generateNameLists ''Arith
-- @
-- 
-- will create
-- 
-- @
-- origASTTypes = [mkName "Foo.Arith", mkName "Foo.Atom", mkName "Foo.Lit"]
-- newASTTypes  = [mkName "Arith", mkName "Atom", mkName "Lit"]
-- @
generateNameLists :: Name -> Q [Dec]
generateNameLists root = do descs <- collectTypes root
                            nameList1 <- mkNameList (mkName "origASTTypes") descs
                            nameList2 <- mkNameList (mkName "newASTTypes") (map transName descs) 

                            return $ nameList1 ++ nameList2

mkNameList :: Name -> [Name] -> Q [Dec]
mkNameList name contents = sequence [ sigD name (appT listT (conT ''Name))
                                    , valD (varP name) (normalB namesExp) []
                                    ]
  where
    namesExp = dataToExpQ (const Nothing) contents

-- |
-- Folds together names with @(`:+:`)@.
-- 
-- /e.g./
-- 
-- @
-- import qualified Foo as F
-- deriveMult ''F.Arith
-- makeSumType \"ArithSig\" [''Arith, ''Atom, ''Lit]
-- @
-- 
-- will create
-- 
-- @
-- type ArithSig = Arith :+: Atom :+: Lit
-- @
-- 
-- You can use `generateNameLists` to avoid spelling out the names manually
makeSumType :: String -> [Name] -> Q [Dec]
makeSumType nm types = sequence $ [tySynD (mkName nm) [] $ sumType types]
  where
    sumType []     = fail "Attempting to make empty sum type"
    sumType [t]    = conT t
    sumType (t:ts) = appT (appT (conT ''(:+:)) (conT t)) (sumType ts)